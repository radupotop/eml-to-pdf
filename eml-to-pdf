#!/usr/bin/env python3

from email import policy
from email.message import Message
from email.parser import BytesParser
from email.utils import parsedate_to_datetime
from pathlib import Path
from zoneinfo import ZoneInfo

from bs4 import BeautifulSoup
from weasyprint import HTML

EML_HEADERS = ['From', 'To', 'Cc', 'Subject', 'Date']
TS_FORMAT = '%-d %B %Y, %H:%M'  # https://strftime.org/
TZ = ZoneInfo('Europe/London')


def strip_html_tags(html_source):
    """Strip all HTML tags and return plain text."""
    soup = BeautifulSoup(html_source, 'html.parser')
    return soup.get_text()


def read_eml(eml_path) -> Message:
    # Load the email
    fb = Path(eml_path).read_bytes()
    msg = BytesParser(policy=policy.default).parsebytes(fb)
    return msg


def parse_headers(msg: Message):
    headers = dict()
    for _h in EML_HEADERS:
        if _h == 'Date':
            headers[_h] = parsedate_to_datetime(msg[_h]).astimezone(TZ)
        elif _h == 'Subject':
            headers[_h] = msg.get(_h, '–').replace('/', '_')
        else:
            headers[_h] = msg.get(_h, '–').replace('<', '&lt;').replace('>', '&gt;')
    return headers


def render_headers(headers: dict):
    return '\n'.join([f'<strong>{k}:</strong> {v}</br>' for k, v in headers.items()])


def parse_part(part: Message) -> str | None:
    content_type = part.get_content_type()
    print(content_type)
    payload = None
    if content_type in ('text/plain', 'text/html'):
        charset = part.get_content_charset() or 'utf-8'
        payload = part.get_payload(decode=True).decode(charset, 'ignore')
    if content_type == 'text/html':
        payload = strip_html_tags(payload)
    return payload


def parse_multipart(msg: Message):
    if msg.is_multipart():
        for part in msg.iter_parts():
            if part.is_multipart():
                return parse_multipart(part)
            else:
                return parse_part(part)
    else:
        return parse_part(msg)


def eml_to_html(msg: Message):
    # Extract headers
    headers = parse_headers(msg)

    # Prepare HTML content
    html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Email: {headers.get('Subject')}</title>
    <meta name="author" content="{headers.get('From')}">
    <meta name="dcterms.created" content="{headers.get('Date').isoformat()}">
    <link rel="stylesheet" href="file:///home/radu/Projects/eml-to-pdf/style.css">
</head>
<body>
    <p class="header">
        {render_headers(headers)}
    </p>
    <div class="content">
"""

    html_content += parse_multipart(msg) or ''

    html_content += """
    </div>
</body>
</html>
"""
    return html_content


def save_pdf_from_html(html_content, pdf_path):
    Path(pdf_path + '.html').write_text(html_content)
    HTML(string=html_content).write_pdf(pdf_path)


# Example usage:
eml_path = '2024-06-07_1219 update - Steven Strauss <steven@quantumgroup.uk>.eml'
raw_eml = read_eml(eml_path)
html_content = eml_to_html(raw_eml)
save_pdf_from_html(html_content, eml_path + '.pdf')
