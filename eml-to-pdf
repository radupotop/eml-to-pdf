#!/usr/bin/env python3

import argparse
import html
import sys
from email import policy
from email.message import EmailMessage, MIMEPart
from email.parser import BytesParser
from email.utils import parsedate_to_datetime
from pathlib import Path
from typing import NamedTuple
from zoneinfo import ZoneInfo

import weasyprint as wp
from bs4 import BeautifulSoup

EML_CONTENT_TYPES = ('text/html', 'text/plain')
EML_HEADERS = ('Date', 'Subject', 'From', 'To', 'Cc', 'Bcc')
PREFERRED = EML_CONTENT_TYPES[0]
TS_FORMAT = '%-d %B %Y, %H:%M'  # https://strftime.org/
TZ = ZoneInfo('Europe/London')


class ParsedPart(NamedTuple):
    content_type: str
    payload: str


def strip_html_tags(html_source: str) -> str:
    soup = BeautifulSoup(html_source, 'html.parser')
    # for tag in soup.find_all(style=True):
    #     print(tag.name, '\t', tag['style'], file=sys.stderr)
    #     del tag['style']
    if soup.body:
        return ''.join(map(str, soup.body.contents))
    return ''


def read_eml(eml_path: str) -> EmailMessage:
    # Load the email
    fb = Path(eml_path).read_bytes()
    msg = BytesParser(policy=policy.default).parsebytes(fb)
    return msg


def parse_single_header(msg: EmailMessage, head: str):
    '''
    Parse a single msg header at a time.
    '''
    if head == 'Date':
        return parsedate_to_datetime(msg[head]).astimezone(TZ)
    return html.escape(msg.get(head, ''))


def parse_all_headers(msg: EmailMessage):
    header_values = [parse_single_header(msg, h) for h in EML_HEADERS]
    return dict(zip(EML_HEADERS, header_values))


def render_headers(headers: dict) -> str:
    headers['Date'] = headers['Date'].strftime(TS_FORMAT)
    return '\n'.join(
        [f'<tr><th>{k}:</th><td>{v}</td></tr>' for k, v in headers.items() if v]
    )


def parse_part(part: MIMEPart) -> ParsedPart | None:
    if part.is_attachment():
        return
    content_type = part.get_content_type()
    if content_type in EML_CONTENT_TYPES:
        print(content_type, file=sys.stderr)
        charset = part.get_content_charset() or 'utf-8'
        payload = part.get_payload(decode=True).decode(charset, 'ignore')
        if content_type == 'text/html':
            payload = strip_html_tags(payload)
        return ParsedPart(content_type, payload)


def parse_multipart(msg: EmailMessage) -> ParsedPart:
    part_map = dict()
    for part in msg.walk():  # flat list of all sub-parts
        if p := parse_part(part):
            part_map[p.content_type] = p
    return part_map[PREFERRED]


def eml_to_html(msg: EmailMessage):
    # Extract headers
    headers = parse_all_headers(msg)
    mimetype, content = parse_multipart(msg)

    # Prepare HTML content
    html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Email: {headers.get('Subject')}</title>
    <meta name="author" content="{headers.get('From')}">
    <meta name="dcterms.created" content="{headers.get('Date').isoformat()}">
    <link rel="stylesheet" href="file:///home/radu/Projects/eml-to-pdf/style.css">
</head>
<body>
    <div id="headers">
    <table>
    <tbody>
{render_headers(headers)}
    </tbody>
    </table>
    </div>
    <div id="content" class="{mimetype.replace('/', '-')}">
{content}
    </div>
</body>
</html>
"""
    return html_content


def save_html(path, html_content):
    outpath = Path(path).with_suffix('.html')
    outpath.write_text(html_content)
    print(outpath, file=sys.stderr)


def save_pdf(path, html_content):
    pdf_path = Path(path).with_suffix('.pdf')
    wp.HTML(string=html_content).write_pdf(pdf_path)
    print(f'"{pdf_path}"')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('email_files', type=str, nargs='+')
    args = parser.parse_args()
    # Run all
    for eml_path in args.email_files:
        raw_eml = read_eml(eml_path)
        html_content = eml_to_html(raw_eml)
        save_html(eml_path, html_content)
        save_pdf(eml_path, html_content)
