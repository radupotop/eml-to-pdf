#!/usr/bin/env python3

import argparse
import html
from email import policy
from email.message import Message
from email.parser import BytesParser
from email.utils import parsedate_to_datetime
from pathlib import Path
from zoneinfo import ZoneInfo

from bs4 import BeautifulSoup
from weasyprint import HTML

EML_HEADERS = ['Date', 'Subject', 'From', 'To', 'Cc', 'Bcc']
TS_FORMAT = '%-d %B %Y, %H:%M'  # https://strftime.org/
TZ = ZoneInfo('Europe/London')


def strip_html_tags(html_source):
    """Strip all HTML tags and return plain text."""
    soup = BeautifulSoup(html_source, 'html.parser')
    return soup.get_text()


def read_eml(eml_path) -> Message:
    # Load the email
    fb = Path(eml_path).read_bytes()
    msg = BytesParser(policy=policy.default).parsebytes(fb)
    return msg


def parse_single_header(msg: Message, head: str):
    '''
    Parse a single msg header at a time.
    '''
    if head == 'Date':
        return parsedate_to_datetime(msg[head]).astimezone(TZ)
    return html.escape(msg.get(head, 'â€“'))


def parse_all_headers(msg: Message):
    header_values = [parse_single_header(msg, h) for h in EML_HEADERS]
    return dict(zip(EML_HEADERS, header_values))


def render_headers(headers: dict):
    return '\n'.join([f'<strong>{k}:</strong> {v}</br>' for k, v in headers.items()])


def parse_part(part: Message) -> str | None:
    content_type = part.get_content_type()
    print(content_type)
    payload = None
    if content_type in ('text/plain', 'text/html'):
        charset = part.get_content_charset() or 'utf-8'
        payload = part.get_payload(decode=True).decode(charset, 'ignore')
    if content_type == 'text/html':
        payload = strip_html_tags(payload)
    return payload


def parse_multipart(msg: Message):
    if msg.is_multipart():
        for part in msg.iter_parts():
            if part.is_multipart():
                return parse_multipart(part)
            else:
                return parse_part(part)
    else:
        return parse_part(msg)


def eml_to_html(msg: Message):
    # Extract headers
    headers = parse_all_headers(msg)
    content = parse_multipart(msg)

    # Prepare HTML content
    html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Email: {headers.get('Subject')}</title>
    <meta name="author" content="{headers.get('From')}">
    <meta name="dcterms.created" content="{headers.get('Date').isoformat()}">
    <link rel="stylesheet" href="file:///home/radu/Projects/eml-to-pdf/style.css">
</head>
<body>
    <p id="headers">
{render_headers(headers)}
    </p>
    <div id="content">
{content}
    </div>
</body>
</html>
"""
    return html_content


def save_html(path, html_content):
    Path(path).with_suffix('.html').write_text(html_content)


def save_pdf(path, html_content):
    HTML(string=html_content).write_pdf(Path(path).with_suffix('.pdf'))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('email_files', type=str, nargs='+')
    args = parser.parse_args()
    # runall(map(Path, args.email_files))
    for eml_path in args.email_files:
        raw_eml = read_eml(eml_path)
        html_content = eml_to_html(raw_eml)
        save_html(eml_path, html_content)
        save_pdf(eml_path, html_content)
